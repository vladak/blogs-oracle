<html><body>
<head>
            <title>poll(2) and POLLHUP with pipes in Solaris | Oracle Czech techie's adventures Blog</title>
<meta name="publish_date" content="2008-04-13 14:20:50">
</head>
                                                                    <p>During nc(1) preintegration testing, short time before it <a href="http://blogs.sun.com/vlad/entry/netcat_in_solaris">went back</a><br/>I had found that '<tt>cat /etc/passwd | nc localhost 4444</tt>' produced endless loop with <br/>100% CPU utilization, looping in calls doing poll(2) (I still remember my laptop suddenly getting much warmer<br/>than it should be and CPU fan cranking up).<br/>'<tt>nc localhost 4444 &lt; /etc/password</tt>' was not exhibiting that behavior.<br/><br/><br/>The cause was a difference between poll(2) implementation on BSD and Solaris. Since I am working on Netcat<br/>in Solaris again (adding more features, stay tuned), it's time to take a look back <br/>and maybe even help people porting similar software from BSD to Solaris.</p><p>The issue appears because <tt>POLLHUP</tt> is set in read events bitfield for <tt>stdin</tt> after pipe is<br/>closed (or to be more precise - after the producer/write end is done) on Solaris.<br/><a href="http://blogs.sun.com/vlad/resource/poll.c"><tt>poll.c</tt></a> (which resembles<br/><a href="http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/cmd/cmd-inet/usr.bin/nc/netcat.c#readwrite">readwrite()</a><br/>function from <tt>nc</tt>) illustrates the issue:</p><pre>01 #include &lt;stdio.h&gt;<br/>02 #include &lt;poll.h&gt;<br/>03 <br/>04 #define LEN  1024<br/>05 <br/>06 int main(void) {<br/>07      int timeout = -1;<br/>08      int n;<br/>09      char buf[LEN];<br/>10      int plen = LEN;<br/>11 <br/>12      struct pollfd pfd;<br/>13 <br/>14      pfd.fd = fileno(stdin);<br/>15      pfd.events = POLLIN;<br/>16 <br/>17      while (pfd.fd != -1) {<br/>18              if ((n = poll(&amp;pfd, 1, timeout)) < 0) {<br/>19                      err(1, "Polling Error");<br/>20              }<br/>21              fprintf(stderr, "revents = 0x%x [ %s %s ]&#92;&#92;n",<br/>22                  pfd.revents,<br/>23                  pfd.revents &amp; POLLIN ? "POLLIN" : "",<br/>24                  pfd.revents &amp; POLLHUP ? "POLLHUP" : "");<br/>25      <br/>26              if (pfd.revents & (POLLIN|POLLHUP)) {<br/>27                      if ((n = read(fileno(stdin), buf, plen)) < 0) {<br/>28                              fprintf(stderr,<br/>29                                  "read() returned neg. val (%d)&#92;&#92;n", n);<br/>30                              return;<br/>31                      } else if (n == 0) {<br/>32                              fprintf(stderr, "read() returned 0&#92;&#92;n", n);<br/>33                              pfd.fd = -1;<br/>34                              pfd.events = 0;<br/>35                      } else {<br/>36                              fprintf(stderr, "read: %d bytes&#92;&#92;n", n);<br/>37                      }<br/>38              }<br/>39      }<br/>40 }</pre><p>Running it on NetBSD (chosen because my personal non-work mailbox is hosted on a machine running it)<br/>produces the following:</p><pre>otaku[~]% ( od -N 512 -X -v /dev/zero | sed 's/ [ &#92;&#92;t]&#92;*/ /g'; sleep 3 ) | ./poll<br/>revents = 0x1 [ POLLIN  ]<br/>read: 1024 bytes<br/>revents = 0x1 [ POLLIN  ]<br/>read: 392 bytes<br/>revents = 0x11 [ POLLIN POLLHUP ]<br/>read() returned 0</pre><p>I had to post-process the output of od(1) (because of difference between output of od(1) on NetBSD <br/>and Solaris) and slow the execution down a bit (via <tt>sleep</tt>) in order to make things more visible <br/>(try to run the command without the sleep and the pipe will be closed too quickly).<br/>On OpenSolaris the same program produces different pattern:</p><pre>moose:~&#36; ( od -N 512 -X -v /dev/zero | sed 's/ [ &#92;&#92;t]&#92;*/ /g' ; sleep 3 ) | ./poll <br/>revents = 0x1 [ POLLIN  ]<br/>read: 1024 bytes<br/>revents = 0x1 [ POLLIN  ]<br/>read: 392 bytes<br/>revents = 0x10 [  POLLHUP ]<br/>read() returned 0</pre><p>So, the program is now obviously correct. Had the statement on line 26 checked only <tt>POLLIN</tt>,<br/>the command above (with or without the <tt>sleep</tt>) would go into endless loop on Solaris: </p><pre>revents = 0x11 [ POLLIN POLLHUP ]<br/>read: 1024 bytes<br/>revents = 0x11 [ POLLIN POLLHUP ]<br/>read: 392 bytes<br/>revents = 0x10 [  POLLHUP ]<br/>revents = 0x10 [  POLLHUP ]<br/>revents = 0x10 [  POLLHUP ]<br/>...</pre><p>Both OSes set <tt>POLLHUP</tt> after the pipe is closed. The difference is that while BSD always <br/>indicates <tt>POLLIN</tt> (even if there is nothing to read), Solaris strips it after data stream ended.<br/>So, which one is correct ?<br/><a href="http://www.opengroup.org/onlinepubs/009695399/functions/poll.html">poll() function</a> as<br/>described by <a href="http://www.opengroup.org/">OpenGroup</a> says that <br/>"<quote><tt>POLLHUP</tt> and <tt>POLLIN</tt> are not mutually exclusive</quote>".<br/>This means both implementations seem to conform to the <i>IEEE Std 1003.1, 2004 Edition</i> standard<br/>(part of <a href="http://en.wikipedia.org/wiki/POSIX">POSIX</a>) in this respect.</p><p>However, the POSIX standard also says:</p><ul><i><br/>      In each pollfd structure, poll ( ) shall clear the revents member, except that where the application<br/>      requested a report on a condition by setting one of the bits of events listed above, poll ( ) shall set<br/>      the corresponding bit in revents if the requested condition is true. In addition, poll ( ) shall set the<br/>      POLLHUP, POLLERR, and POLLNVAL flag in revents if the condition is true, even if the<br/>      application did not set the corresponding bit in events.</i></ul><p>This might be still ok even though <tt>POLLIN</tt> flag<br/>remains to be set in NetBSD's poll() even after no data are available for reading (try to comment out lines <br/>33,34 and run as above) because the standard says about <tt>POLLIN</tt> flag: <br/><i>For STREAMS, this flag is set in revents even if the message is of zero length</i>.</p><p>Without further reading it is hard to tell how exactly should POSIX compliant poll() look like.<br/>On the<br/><a href="http://en.wikipedia.org/wiki/Austin_Group">Austin group</a> mailing list<br/>there was a<br/><a href="http://www.opengroup.org/austin/mailarchives/ag/msg11243.html">thread about poll() behavior w.r.t. POLLHUP</a><br/>suggesting this is fuzzy area.</p><p>Anyway, to see where exactly is <tt>POLLHUP</tt> set for pipes in OpenSolaris go to <a href="http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/fs/fifofs/fifovnops.c#fifo_poll"><tt>fifo_poll()</tt></a>. The function _sets_ the <tt>revents</tt> bit field to <tt>POLLHUP</tt> so the <tt>POLLIN</tt> flag is wiped off after that.<br/><tt>fifo_poll()</tt> is part of <tt>fifofs</tt> kernel module which has been around in Solaris since late eighties <br/>(I was still in elementary school the year  <a href="http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/fs/fifofs/fifovnops.c"><tt>fifovnops.c</tt></a><br/>appeared in <a href="http://en.wikipedia.org/wiki/SunOS">SunOS</a> code base :)).<br/>NetBSD has <tt>fifofs</tt> too but the <tt>POLLHUP</tt> flag gets set via bit logic operation in <a href="http://opengrok.netbsd.org/source/xref/sys/kern/sys_pipe.c#pipe_poll">pipe_poll()</a> which is part of syscall processing code.<br/>The difference between OpenSolaris and NetBSD (whoa, NetBSD project uses <br/><a href="http://opensolaris.org/os/project/opengrok/">OpenGrok</a> !) <tt>POLLHUP</tt> attitude (respectively) is now clear:</p><p><img src="pollhup_solaris_netbsd.jpg"></p>
</body></html>
