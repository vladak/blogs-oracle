<html><body>
<head>
            <title>strsep() in libc | Oracle Czech techie's adventures Blog</title>
<meta name="publish_date" content="2008-09-03 14:45:59">
</head>
                                                                    <p>As of today, strsep() function <a href="http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/lib/libc/port/gen/strsep.c">lives</a> <br/>in <a href="http://opensolaris.org/os/project/onnv/">Nevada</a>'s libc (tracked by <a href="http://bugs.opensolaris.org/view_bug.do?bug_id=4383867">CR 4383867</a> and <a href="http://www.opensolaris.org/os/community/arc/caselog/2008/305/">PSARC 2008/305</a>). This constitutes another step in <br/>the quest for more feature-full (in terms of compatibility) libc in OpenSolaris. In binary form, the changes will be available<br/>in build 99. The documentation will be part of the string(3C) man page.</p><p>Here's a small example of how to use it:</p><pre>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;err.h&gt;<br/>int parse(const char &#92;*str) {<br/>        char &#92;*p = NULL;<br/>        char &#92;*inputstring, &#92;*origstr;<br/>        int ret = 1;<br/>        if (str == NULL)<br/>                errx(1, "NULL string");<br/>        /&#92;*<br/>         &#92;* We have to remember original pointer because strsep()<br/>         &#92;* will change 'inputstr' pointer.<br/>         &#92;*/<br/>        if ((origstr = inputstring = strdup(str)) == NULL)<br/>                errx(1, "strdup() failed");<br/>        printf("=== parsing '%s'&#92;&#92;n", inputstring);<br/>        for ((p = strsep(&inputstring, ",")); p != NULL;<br/>           (p = strsep(&inputstring, ","))) {<br/>                if (p != NULL &amp;&amp; &#92;*p != '&#92;&#92;0')<br/>                        printf("%s&#92;&#92;n", p);<br/>                else if (p != NULL) {<br/>                        warnx("syntax error");<br/>                        ret = 0;<br/>                        goto bad;<br/>                }<br/>        }<br/>bad:<br/>        printf("=== finished parsing&#92;&#92;n");<br/>        free(origstr);<br/>        return (ret);<br/>}<br/>int main(int argc, char &#92;*argv[]) {<br/>        if (argc != 2)<br/>                errx(1, "usage: prog <string>");<br/>        if (!parse(argv[1]))<br/>                exit(1);<br/>        return (0);<br/>}</pre><p>This example was actually used as a unit test (use e.g. <tt>"1,22,33,44"</tt> and <tt>"1,22,,44,33"</tt> as input string) <br/>and it also nicely illustrates important properties of strsep() behavior:</p><ul><li><br/>  While searching for tokens, strsep() modifies the original string. This is shared property with strtok().</li><li><br/>  Unlike strtok(), strsep() is able to detect empty fields.</li></ul><p>There is a function in Solaris' libc which can do token splitting and does not modify the original string - strcspn().<br/>The other notable property of strsep() is that (unlike strtok()) it does not conform to ANSI-C. Time to draw a table:</p><pre> function(s)   ISO C90    modifies     detects<br/>                           input     empty fields<br/>-------------+----------+----------+--------------+<br/> strsep()        No          Yes         Yes<br/> strtok()        Yes         Yes         No<br/> strcspn()       Yes         No        Sort of</pre><p>None of the above functions is bullet-proof. The bottom line is the user should decide which is the most<br/>suitable for given task and use it with its properties in mind.</p>
</body></html>
