<html><body>
<head>
            <title>netcat and network stack debugging | Oracle Czech techie's adventures Blog</title>
<meta name="publish_date" content="2010-06-02 03:37:46">
</head>
                                                                    <p>One of the options of the netcat program (<tt>/usr/bin/nc</tt>) available in OpenSolaris (if you don't have it installed simply run <tt>pkg install SUNWnetcat</tt>)<br/>is the -D (aka debugging) option. Only recently I realized that not everyone out there knows how to capture the debugging data once this option<br/>is set since this is pretty Solaris specific. What this option does is basically trigger a flag inside the ip kernel module specific for given<br/>connection structure (<tt>conn_t</tt>). netcat does this by calling <tt>setsockopt()</tt> system call with <tt>SO_DEBUG</tt> option set for given<br/>socket. As a result <tt>conn_debug</tt> flag is set inside <tt>conn_t</tt> structure associated with the socket. This flag is then consulted in <br/>various functions manipulating the structure.</p><p>When there is an interesting event and the <tt>conn_debug</tt> is set the function calls <tt>strlog()</tt> kernel function to record the data.<br/>For example, here's a snippet of <tt>usr/src/uts/common/inet/tcp/tcp_input.c:tcp_input_listener()</tt>:</p><pre>   1366 <p style="text-indent:5em;"></p>if (listener->tcp_conn_req_cnt_q >= listener->tcp_conn_req_max) {<br/>   1367 <p style="text-indent:5em;"></p>mutex_exit(&listener->tcp_eager_lock);<br/>   1368 <p style="text-indent:5em;"></p>TCP_STAT(tcps, tcp_listendrop);<br/>   1369 <p style="text-indent:5em;"></p>TCPS_BUMP_MIB(tcps, tcpListenDrop);<br/>   1370 <p style="text-indent:5em;"></p>if (lconnp->conn_debug) {<br/>   1371 <p style="text-indent:5em;"></p>(void) strlog(TCP_MOD_ID, 0, 1, SL_TRACE|SL_ERROR,<br/>   1372 <p style="text-indent:5em;"></p>    "tcp_input_listener: listen backlog (max=%d) "<br/>   1373 <p style="text-indent:5em;"></p>    "overflow (%d pending) on %s",<br/>   1374 <p style="text-indent:5em;"></p>    listener->tcp_conn_req_max,<br/>   1375 <p style="text-indent:5em;"></p>    listener->tcp_conn_req_cnt_q,<br/>   1376 <p style="text-indent:5em;"></p>    tcp_display(listener, NULL, DISP_PORT_ONLY));<br/>   1377 <p style="text-indent:5em;"></p>}<br/>   1378 <p style="text-indent:5em;"></p>goto error2;<br/>   1379 <p style="text-indent:5em;"></p>}</pre><p>To capture the data logged via <tt>strlog</tt> it's necessary to know the STREAMS module ID, which in our case is<br/><tt>TCP_MOD_ID</tt> which is defined in <tt>usr/src/uts/common/inet/tcp_impl.h</tt> as 5105.</p><p>To read the data one can use either strace(1M) command line tool or strerr(1M) daemon which both produce text logs.<br/>To read everything, one can use this command (needs read access to <tt>/dev/log</tt> so has to run under root):</p><pre># strace 5105 all all</pre><p>Here are two examples using netcat: at first we try to bind to a port which we don't have privileges for:</p><pre>&#36; nc -D -l -4 -p 23<br/>nc: Permission denied</pre><p>which produces the following entry from strace:</p><pre>000004 12:11:04 19c7ff6a  1 ..E 5105 0 ip: [ID 234745 kern.debug] tcp_bind: no priv for port 23</pre><p>next we try to bind to already occupied port:</p><pre>&#36; nc -D -l -4 -p 4444<br/>nc: Address already in use</pre><p>which produces the following entry from strace:</p><pre>000005 12:15:33 19c86878  1 ..E 5105 0 ip: [ID 326978 kern.debug] tcp_bind: requested addr busy</pre><p>This is of course traceable via normal tools such as ppriv(1) or truss(1) but the point is that much fine grained details<br/>can be captured from the network modules. The format of the log entries is explained in the strace(1M) man page.</p>
</body></html>
