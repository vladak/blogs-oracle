<html><body>
<head>
            <title>signal() versus sigaction() on Solaris | Oracle Czech techie's adventures Blog</title>
<meta name="publish_date" content="2009-10-30 04:21:28">
</head>
                                                                    <p>This entry is mostly for newcomers to Solaris/OpenSolaris from UNIX-like systems. When I had been taught<br/>about <tt>signal()</tt> and <tt>sigaction()</tt> my understanding was that <tt>sigaction()</tt> is just a<br/>superset of <tt>signal()</tt> and also POSIX conformant but otherwise they accomplish the same thing.<br/>This is indeed the case for some of UNIX-like operating systems. In Solaris, as I only recently discovered <br/>(to my dismay :)), it's different.</p><p>Consider the following code (please ignore the fact it's not strictly checking return values and <br/>that the signal handler is not safe):</p><pre>#include &lt;stdio.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include &lt;sys/types.h&gt;<br/>void sig_handler(int s) {<br/><p style="text-indent:5em;"></p>printf("Got signal! Sleeping.&#92;&#92;n");<br/><p style="text-indent:5em;"></p>sleep(10);<br/>        printf("returning from signal handler&#92;&#92;n");<br/>}<br/>int main(void) {<br/>        struct sigaction s_action;<br/><p style="text-indent:5em;"></p>printf("Setting signal handler: ");<br/>#ifdef POSIX_SIGNALS<br/><p style="text-indent:5em;"></p>printf("sigaction&#92;&#92;n");<br/><p style="text-indent:5em;"></p>(void) sigemptyset(&s_action.sa_mask);<br/><p style="text-indent:5em;"></p>s_action.sa_handler = sig_handler;<br/>        s_action.sa_flags = 0;<br/><p style="text-indent:5em;"></p>(void) sigaction(SIGHUP, &s_action, (struct sigaction &#92;*) NULL);<br/>#else<br/><p style="text-indent:5em;"></p>printf("signal&#92;&#92;n");<br/><p style="text-indent:5em;"></p>signal(SIGHUP, sig_handler);<br/>#endif<br/><p style="text-indent:5em;"></p>printf("Waiting for signal&#92;&#92;n");<br/><p style="text-indent:5em;"></p>while(1)<br/><p style="text-indent:5em;"></p>pause();<br/><p style="text-indent:5em;"></p>return (0);<br/>}</pre><p>Now try to compile and run with and without the <tt>-DPOSIX_SIGNALS</tt> and send 2 SIGHUP signals to the process<br/>within the 10 seconds window (so the second signal is received while the signal handler is still running).<br/>With <tt>sigaction()</tt>, the signal will be caught by the handler in both of the cases.<br/>With <tt>signal()</tt> however, the second signal will cause the process to exit. This is because kernel<br/>will reset the signal handler to default upon receiving the signal for the first time. This is described in the signal(3C)<br/>man page in a somewhat hidden sentence inside the second paragraph (it really pays out to read man pages slowly and<br/>with attention to detail):</p><pre>     If signal()  is<br/>     used,  disp  is  the address of a signal handler, and sig is<br/>     not  SIGILL, SIGTRAP, or  SIGPWR, the system first sets  the<br/>     signal's disposition to  SIG_DFL before executing the signal<br/>     handler.</pre><p>The sigaction(2) man page has this section:</p><pre>     SA_RESETHAND    If set and the signal is caught, the  dispo-<br/>                     sition of the signal is reset to SIG_DFL and<br/>                     the signal will not be blocked on  entry  to<br/>                     the  signal  handler  (SIGILL,  SIGTRAP, and<br/>                     SIGPWR cannot be  automatically  reset  when<br/>                     delivered; the system silently enforces this<br/>                     restriction).</pre><p>sigaction() does not set the flag by default which results in the different behavior.<br/>I found out that this behavior has been present since Solaris 2.0 or so.</p><p>In fact, <tt>signal()</tt> routine from libc is implemented via <tt>sigaction()</tt>. From <br/><a href="http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/lib/libc/port/sys/signal.c#signal">&#36;SRC/lib/libc/port/sys/signal.c</a>:</p><pre>     58 /&#92;*<br/>     59  &#92;* SVr3.x signal compatibility routines. They are now<br/>     60  &#92;* implemented as library routines instead of system<br/>     61  &#92;* calls.<br/>     62  &#92;*/<br/>     63 <br/>     64 void(&#92;*<br/>     65 signal(int sig, void(&#92;*func)(int)))(int)<br/>     66 {<br/>     67 <p style="text-indent:5em;"></p>struct sigaction nact;<br/>     68 <p style="text-indent:5em;"></p>struct sigaction oact;<br/>     69 <br/>     70 <p style="text-indent:5em;"></p>CHECK_SIG(sig, SIG_ERR);<br/>     71 <br/>     72 <p style="text-indent:5em;"></p>nact.sa_handler = func;<br/>     73 <p style="text-indent:5em;"></p>nact.sa_flags = SA_RESETHAND|SA_NODEFER;<br/>     74 <p style="text-indent:5em;"></p>(void) sigemptyset(&nact.sa_mask);<br/>     75 <br/>     76 <p style="text-indent:5em;"></p>/&#92;*<br/>     77 <p style="text-indent:5em;"></p> &#92;* Pay special attention if sig is SIGCHLD and<br/>     78 <p style="text-indent:5em;"></p> &#92;* the disposition is SIG_IGN, per sysV signal man page.<br/>     79 <p style="text-indent:5em;"></p> &#92;*/<br/>     80 <p style="text-indent:5em;"></p>if (sig == SIGCHLD) {<br/>     81 <p style="text-indent:5em;"></p>nact.sa_flags |= SA_NOCLDSTOP;<br/>     82 <p style="text-indent:5em;"></p>if (func == SIG_IGN)<br/>     83 <p style="text-indent:5em;"></p>nact.sa_flags |= SA_NOCLDWAIT;<br/>     84 <p style="text-indent:5em;"></p>}<br/>     85 <br/>     86 <p style="text-indent:5em;"></p>if (STOPDEFAULT(sig))<br/>     87 <p style="text-indent:5em;"></p>nact.sa_flags |= SA_RESTART;<br/>     88 <br/>     89 <p style="text-indent:5em;"></p>if (sigaction(sig, &nact, &oact) < 0)<br/>     90 <p style="text-indent:5em;"></p>return (SIG_ERR);<br/>     91 <br/>     92 <p style="text-indent:5em;"></p>return (oact.sa_handler);<br/>     93 }</pre><p>I am pretty sure that the <tt>SA_RESETHAND</tt> flag is set in signal() in order to preserve backwards compatibility.</p><p>This means that to solve this problem with signal(), one should set the signal handler again in the signal handler itself.<br/>However, this is not a complete solution since there is still a window where the signal can be delivered and<br/>the handler is set to <tt>SIG_DFL</tt> - the default handler which is exit in case of <tt>SIGHUP</tt> as<br/>the signal.h(3HEAD) man page explains in really useful table:</p><pre>          Name        Value   Default                    Event<br/>     SIGHUP           1       Exit       Hangup (see termio(7I))<br/>     ...</pre><p>Now let's look at FreeBSD. Its SIGNAL(3) man page contains this separate paragraph:</p><pre>     The handled signal is unblocked when the function returns and the process<br/>     continues from where it left off when the signal occurred.  Unlike previ-<br/>     ous signal facilities, the handler func() remains installed after a sig-<br/>     nal has been delivered.</pre><p>The second sentence is actually printed in bold letters. I also tried on Linux and NetBSD and<br/>the behavior is the same as in FreeBSD.</p><p>So, to conclude all of the above: using signal() is really not portable.</p>
</body></html>
