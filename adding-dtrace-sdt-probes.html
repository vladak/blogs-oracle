<html><body>
<head>
            <title>Adding dtrace SDT probes | Oracle Czech techie's adventures Blog</title>
<meta name="publish_date" content="2008-01-17 02:33:59">
</head>
                                                                    <p>It seems that many developers and <a href="http://www.opensolaris.org/os/community/dtrace/">dtrace users</a> found themselves in a position where they<br/>wanted to add some <a href="http://docs.sun.com/app/docs/doc/817-6223/chp-sdt?a=view">SDT probes</a> to a module to get more insight into what's going on but the had to pause<br/>and were thinking <i>"okay, more probes. But where to put them ? Do I really<br/>need the additional probes when I already have the <a href="http://docs.sun.com/app/docs/doc/817-6223/chp-fbt?a=view">fbt</a> ones ?"</i>.<br/>To do this, systematic approach is needed in order not to over-do or under-do.<br/>I will use KSSL (Solaris kernel SSL proxy <a href="#footnote1">[1]</a>) for illustration. </p><p>With CR <a href="http://src.opensolaris.org/source/search?q=&defs=&refs=&path=&hist=6556447&project=%2Fonnv">6556447</a>,<br/>tens of SDT probes were introduced into KSSL module and other modules which interface with it.<br/>Also, in addition to the new SDT probes, in KSSL we got rid of the <br/><tt>KSSL_DEBUG</tt> macros compiled only in DEBUG kernels and substituted them with <br/>SDT probes. As a result, much better observability and error detection was achieved <br/>with both debug and non-debug kernels. The other option would be to create KSSL<br/>dtrace provider but that would be too big gun for what is needed to achieve.</p><p>Generically, the following interesting data points for data gathering/observation <br/>can be identified in code:</p><ul><li>data paths<br/><br/>  When there is a more than one path how data could flow into a subsystem.<br/>  E.g. for TCP we have couple of cases how SSL data could reach KSSL input queue.<br/>  To identify where from exactly was <tt>tcp_kssl_input()</tt> called we use SDT probes:<pre><p style="text-indent:5em;"></p>if (tcp->tcp_listener || tcp->tcp_hard_binding) {<br/>...<br/><p style="text-indent:5em;"></p>if (tcp->tcp_kssl_pending) {<br/><p style="text-indent:5em;"></p>DTRACE_PROBE1(kssl_mblk__ksslinput_pending,<br/><p style="text-indent:5em;"></p>    mblk_t &#92;*, mp);<br/><p style="text-indent:5em;"></p>tcp_kssl_input(tcp, mp);<br/><p style="text-indent:5em;"></p>} else {<br/><p style="text-indent:5em;"></p>tcp_rcv_enqueue(tcp, mp, seg_len);<br/><p style="text-indent:5em;"></p>}<br/><p style="text-indent:5em;"></p>} else {<br/>...<br/><p style="text-indent:5em;"></p>/&#92;* Does this need SSL processing first? &#92;*/<br/><p style="text-indent:5em;"></p>if ((tcp->tcp_kssl_ctx != NULL) &&<br/><p style="text-indent:5em;"></p>    (DB_TYPE(mp) == M_DATA)) {<br/><p style="text-indent:5em;"></p>DTRACE_PROBE1(kssl_mblk__ksslinput_data1,<br/><p style="text-indent:5em;"></p>    mblk_t &#92;*, mp);<br/><p style="text-indent:5em;"></p>tcp_kssl_input(tcp, mp);<br/><p style="text-indent:5em;"></p>} else {<br/><p style="text-indent:5em;"></p>putnext(tcp->tcp_rq, mp);<br/><p style="text-indent:5em;"></p>if (!canputnext(tcp->tcp_rq))<br/><p style="text-indent:5em;"></p>tcp->tcp_rwnd -= seg_len;<br/><p style="text-indent:5em;"></p>}<br/>...</pre></li><li>data processed in while/for cycles<br/><br/>  To observe what happens in each iteration of the cycle. Can be used in code like this:<pre>while (mp != NULL) {<br/>  DTRACE_PROBE1(kssl_mblk__handle_record_cycle, mblk_t &#92;*, mp);<br/>  /&#92;* process the data &#92;*/<br/>  ...<br/>  mp = mp->b_cont;<br/>}</pre></li><li>switch statements<br/><br/>  If significant/non-trivial processing happens inside switch it may be useful to add SDT probes there too. E.g.:<pre>  content_type = (SSL3ContentType)mp->b_rptr[0];<br/>  switch(content_type) {<br/>    /&#92;* select processing according to type &#92;*/<br/>    case content_alert:<br/>       DTRACE_PROBE1(kssl_mblk__content_alert, mblk_t &#92;*, mp);<br/>       ...<br/>       break;<br/>    case content_change_cipher_spec:<br/>       DTRACE_PROBE1(kssl_mblk__change_cipher_spec, mblk_t &#92;*, mp);<br/>       ...<br/>       break;<br/>    default:<br/>       DTRACE_PROBE1(kssl_mblk__unexpected_msg, mblk_t &#92;*, mp);<br/>       break;<br/>  }</pre></li><li>labels which cannot be (easily) identified in other way<br/><br/>  Useful if code which follows the label is generic (assignments, no function calls), e.g.:<pre>                                /&#92;*<br/>                                 &#92;* Give this session a chance to fall back to<br/>                                 &#92;* userland SSL<br/>                                 &#92;*/<br/>                                if (ctxmp == NULL)<br/>                                        goto no_can_do;<br/>...<br/>no_can_do:<br/>                                DTRACE_PROBE1(kssl_no_can_do, tcp_t &#92;*, tcp);<br/>                                listener = tcp->tcp_listener;<br/>                                ind_mp = tcp->tcp_conn.tcp_eager_conn_ind;<br/>                                ASSERT(ind_mp != NULL);</pre>                                </li></ul><p>You've surely noticed that same of the probe definitions above have common prefix <br/>(<tt>kssl_mblk-</tt>). This is one of the things which make SDT probes<br/>so attractive.<br/>With prefixes it is possible to do the e.g. following:</p><pre>sdt:::kssl_err-&#92;*<br/>{<br/>  trace(timestamp);<br/>  printf("hit error in %s&#92;&#92;n", probefunc);<br/>  stack(); ustack();<br/>}</pre><p>The important part is that we do not specify module of function name. <br/>The implicit wildcard (funcname/probename left out) combined with explicit wildcard<br/>(prefix + asterisk) will lead to all KSSL error probes to be activated<br/>regardless of in which module or function there are defined.<br/>This is obviously very useful for technologies which span multiple Solaris<br/>subsystems or modules (such as KSSL).</p><p>The nice thing about the error probes is that they could be leveraged in test suites.<br/>For each test case we can first run dtrace script with the above probeset<br/>covering all KSSL errors in the background and after the test completes<br/>just check if it produced some data. If it did, then the test case can be considered<br/>as failed. No need to check kstat(1M) (and other counters), log files, etc.</p><p>Also, thanks to the way how dtrace probes are activated we can have both<br/>generic <i>probeset</i> (using this for lack of better term) as above with<br/>addition of probe specific action, e.g.:</p><pre>/&#92;* probeset of all KSSL error probes &#92;*/<br/>sdt:::kssl_err-&#92;*<br/>{<br/>  trace(timestamp);<br/>  printf("hit error in %s&#92;&#92;n", probefunc);<br/>}<br/>/&#92;* <br/>  the probe definition is:<br/>     DTRACE_PROBE2(kssl_err__bad_record_size,<br/>         uint16_t, rec_sz, int, spec->cipher_bsize);<br/> &#92;*/<br/>sdt:kssl:kssl_handle_record:kssl_err-bad_record_size<br/>{<br/>  trace(timestamp);<br/>  tracemem(arg0, 32);<br/>  printf("rec_sz = %d , cipher_bsize = %d&#92;&#92;n", arg1, arg2);<br/>}</pre><p>If probe <tt>kssl_err-bad_record_size</tt> gets activated the generic<br/>probe will be activated (and fires) too because the probeset contains the probe.</p><p>Similarly to the error prefix, we can have data specific prefix. For KSSL it is <tt>kssl_mblk-</tt> prefix which could be used for tracing<br/>all mblks (msgb(9S)) as they flow through TCP/IP, STREAMS and KSSL modules. <br/>With such probes it is possible to do e.g. the following:</p><pre>/&#92;* how many bytes from a mblk to dump &#92;*/<br/>#define DUMP_SIZE       48<br/>/&#92;* use macros from <sys/strsun.h> &#92;*/<br/>#define MBLKL(mp)       ((mp)->b_wptr - (mp)->b_rptr)<br/>#define DB_FLAGS(mp)    ((mp)->b_datap->db_flags)<br/>#define PRINT_MBLK_INFO(mp)                                             &#92;&#92;<br/>        printf("mblk = 0x%p&#92;&#92;n", mp);                                    &#92;&#92;<br/>        printf("mblk size = %d&#92;&#92;n", MBLKL((mblk_t &#92;*)mp));                &#92;&#92;<br/>        PRINT_MBLK_PTRS(mp);<br/>#define PRINT_MBLK(mp)                                                  &#92;&#92;<br/>                trace(timestamp);                                       &#92;&#92;<br/>                printf("&#92;&#92;n");                                           &#92;&#92;<br/>                PRINT_MBLK_INFO(mp);                                    &#92;&#92;<br/>                printf("DB_FLAGS = 0x%x", DB_FLAGS((mblk_t &#92;*)mp));      &#92;&#92;<br/>                tracemem(((mblk_t &#92;*)mp)->b_rptr, DUMP_SIZE);            &#92;&#92;<br/>                tracemem(((mblk_t &#92;*)mp)->b_wptr - DUMP_SIZE,            &#92;&#92;<br/>                        DUMP_SIZE);<br/>sdt:::kssl_mblk-&#92;*<br/>{<br/>  trace(timestamp);<br/>  printf("&#92;&#92;n");<br/>  PRINT_MBLK(arg0)<br/>}</pre><p>This is actually an excerpt from my (currently internal) <i>KSSL debugging suite</i>.<br/><br/><br/>An example of output from such probe can be seen in my<br/><a href="http://blogs.sun.com/vlad/entry/coloring_dtrace_output">Coloring dtrace output</a><br/>post.</p><p>For more complex projects it would be waste to stop here. Prefixes could be further<br/>structured. However, this has some drawbacks. In particular, I was thinking about having <br/><tt>kssl_mblk-</tt> and <tt>kssl_err-</tt> prefixes. Now what to do for places<br/>where an error condition occurred _and_ we would like to see the associated mblk ?<br/>Using something like <tt>kssl_mblk_err-&#92;*</tt> comes to ones mind. However, there is a problem <br/>with that - what about the singleton cases (only mblk, only err). Sure, using multiple<br/>wildcards in dtrace is possible (e.g. <tt>syscall::&#92;*read&#92;*:</tt>) but this will<br/>make it ugly and complicated given the number of mblk+err cases (it's probably safe to <br/>assume that the number of such cases will be low). Simply, it's not worth the hassle.<br/>Rather, I went with 2 probes.<br/><br/><br/>To conclude, using structured prefixes is highly beneficial only for set of probes where<br/>categories/sub-prefixes create non-intersecting sets (e.g. data type and debug level).</p><p>Of course, all of the above is not valid only for kernel but also for <a href="http://docs.sun.com/app/docs/doc/817-6223/chp-usdt">custom userland probes</a> !</p><p><a name="footnote1">[1]</a> High-level description of KSSL can be found in <a href="http://www.sun.com/blueprints/0306/819-5782.pdf">blueprint 819-5782</a>.<p>
</body></html>
